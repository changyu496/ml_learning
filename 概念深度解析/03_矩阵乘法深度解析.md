# ğŸ”¢ çŸ©é˜µä¹˜æ³•æ·±åº¦è§£æ

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

> **çŸ©é˜µä¹˜æ³•æ˜¯çº¿æ€§ä»£æ•°çš„æ ¸å¿ƒæ“ä½œï¼Œç†è§£å®ƒå°±ç†è§£äº†æ•°æ®å˜æ¢çš„æœ¬è´¨**

### ä»€ä¹ˆæ˜¯çŸ©é˜µä¹˜æ³•ï¼Ÿ
**å®šä¹‰**ï¼šçŸ©é˜µä¹˜æ³•æ˜¯ä¸¤ä¸ªçŸ©é˜µçš„ç‰¹å®šè¿ç®—ï¼Œäº§ç”Ÿä¸€ä¸ªæ–°çŸ©é˜µã€‚

**æ ¸å¿ƒæ€æƒ³**ï¼šè¡Œä¸åˆ—çš„å†…ç§¯ï¼Œä½“ç°äº†çº¿æ€§å˜æ¢çš„ç»„åˆã€‚

---

## ğŸ“ çŸ©é˜µä¹˜æ³•çš„åŸºæœ¬è§„åˆ™

### å½¢çŠ¶å…¼å®¹æ€§
```python
import numpy as np

# çŸ©é˜µA: (m, n)ï¼ŒçŸ©é˜µB: (n, p) â†’ ç»“æœC: (m, p)
A = np.random.randn(3, 4)  # 3è¡Œ4åˆ—
B = np.random.randn(4, 5)  # 4è¡Œ5åˆ—
C = A @ B                  # 3è¡Œ5åˆ—

print(f"Aå½¢çŠ¶: {A.shape}")
print(f"Bå½¢çŠ¶: {B.shape}")
print(f"Cå½¢çŠ¶: {C.shape}")

# å…³é”®è§„åˆ™ï¼šAçš„åˆ—æ•°å¿…é¡»ç­‰äºBçš„è¡Œæ•°
# Açš„åˆ—æ•° = 4ï¼ŒBçš„è¡Œæ•° = 4 âœ“
```

### ä¸å¯äº¤æ¢æ€§
```python
# çŸ©é˜µä¹˜æ³•ä¸æ»¡è¶³äº¤æ¢å¾‹
A = np.random.randn(3, 4)
B = np.random.randn(4, 2)

AB = A @ B  # (3, 4) @ (4, 2) = (3, 2) âœ“
# BA = B @ A  # (4, 2) @ (3, 4) = ä¸å…¼å®¹ âœ—

print(f"ABå¯ä»¥è®¡ç®—: {AB.shape}")
print("BAæ— æ³•è®¡ç®—ï¼šç»´åº¦ä¸åŒ¹é…")

# å³ä½¿å½¢çŠ¶å…è®¸ï¼Œç»“æœä¹Ÿä¸åŒ
A_square = np.random.randn(3, 3)
B_square = np.random.randn(3, 3)

AB_square = A_square @ B_square
BA_square = B_square @ A_square

print(f"AB â‰  BA: {not np.allclose(AB_square, BA_square)}")
```

---

## ğŸ§® çŸ©é˜µä¹˜æ³•çš„è®¡ç®—åŸç†

### æ‰‹åŠ¨è®¡ç®—ç¤ºä¾‹
```python
# 2x3 çŸ©é˜µä¹˜ä»¥ 3x2 çŸ©é˜µ
A = np.array([[1, 2, 3],
              [4, 5, 6]])  # (2, 3)

B = np.array([[7, 8],
              [9, 10],
              [11, 12]])   # (3, 2)

# æ‰‹åŠ¨è®¡ç®—è¿‡ç¨‹
def manual_matrix_multiply(A, B):
    """æ‰‹åŠ¨å®ç°çŸ©é˜µä¹˜æ³•ï¼Œå±•ç¤ºè®¡ç®—è¿‡ç¨‹"""
    m, n = A.shape
    n2, p = B.shape
    
    if n != n2:
        raise ValueError("çŸ©é˜µç»´åº¦ä¸åŒ¹é…")
    
    C = np.zeros((m, p))
    
    for i in range(m):
        for j in range(p):
            # C[i,j] = Açš„ç¬¬iè¡Œ Â· Bçš„ç¬¬jåˆ—
            value = 0
            for k in range(n):
                value += A[i, k] * B[k, j]
                print(f"C[{i},{j}] += A[{i},{k}] * B[{k},{j}] = {A[i,k]} * {B[k,j]} = {A[i,k] * B[k,j]}")
            C[i, j] = value
            print(f"C[{i},{j}] = {value}\n")
    
    return C

print("æ‰‹åŠ¨è®¡ç®—è¿‡ç¨‹:")
C_manual = manual_matrix_multiply(A, B)

print("NumPyè®¡ç®—ç»“æœ:")
C_numpy = A @ B
print(C_numpy)

print(f"ç»“æœç›¸åŒ: {np.allclose(C_manual, C_numpy)}")
```

### å‘é‡åŒ–ç†è§£
```python
# çŸ©é˜µä¹˜æ³•çš„å‘é‡åŒ–è§‚ç‚¹
A = np.array([[1, 2, 3],
              [4, 5, 6]])

B = np.array([[7, 8],
              [9, 10],
              [11, 12]])

# è§‚ç‚¹1ï¼šè¡Œå‘é‡ä¸åˆ—å‘é‡çš„å†…ç§¯
print("è§‚ç‚¹1ï¼šè¡Œå‘é‡ä¸åˆ—å‘é‡çš„å†…ç§¯")
for i in range(A.shape[0]):
    for j in range(B.shape[1]):
        row = A[i, :]
        col = B[:, j]
        dot_product = np.dot(row, col)
        print(f"ç¬¬{i+1}è¡Œ Â· ç¬¬{j+1}åˆ— = {row} Â· {col} = {dot_product}")

# è§‚ç‚¹2ï¼šçº¿æ€§ç»„åˆ
print("\nè§‚ç‚¹2ï¼šAçš„åˆ—å‘é‡çš„çº¿æ€§ç»„åˆ")
result_col1 = B[0, 0] * A[:, 0] + B[1, 0] * A[:, 1] + B[2, 0] * A[:, 2]
result_col2 = B[0, 1] * A[:, 0] + B[1, 1] * A[:, 1] + B[2, 1] * A[:, 2]

print(f"ç»“æœç¬¬1åˆ—: {result_col1}")
print(f"ç»“æœç¬¬2åˆ—: {result_col2}")
print(f"éªŒè¯: {np.allclose(np.column_stack([result_col1, result_col2]), A @ B)}")
```

---

## ğŸ¯ çŸ©é˜µä¹˜æ³•åœ¨æœºå™¨å­¦ä¹ ä¸­çš„åº”ç”¨

### 1. çº¿æ€§å˜æ¢
```python
# çº¿æ€§å˜æ¢ï¼šæ—‹è½¬çŸ©é˜µ
import matplotlib.pyplot as plt

def create_rotation_matrix(angle):
    """åˆ›å»º2Dæ—‹è½¬çŸ©é˜µ"""
    cos_a = np.cos(angle)
    sin_a = np.sin(angle)
    return np.array([[cos_a, -sin_a],
                     [sin_a, cos_a]])

# åŸå§‹ç‚¹
points = np.array([[1, 0],
                   [0, 1],
                   [-1, 0],
                   [0, -1]]).T  # (2, 4)

# æ—‹è½¬45åº¦
rotation_matrix = create_rotation_matrix(np.pi/4)
rotated_points = rotation_matrix @ points

print(f"æ—‹è½¬çŸ©é˜µ:\n{rotation_matrix}")
print(f"åŸå§‹ç‚¹:\n{points}")
print(f"æ—‹è½¬å:\n{rotated_points}")

# éªŒè¯ï¼šæ—‹è½¬ä¿æŒè·ç¦»
original_distances = np.linalg.norm(points, axis=0)
rotated_distances = np.linalg.norm(rotated_points, axis=0)
print(f"è·ç¦»ä¿æŒä¸å˜: {np.allclose(original_distances, rotated_distances)}")
```

### 2. çº¿æ€§å›å½’
```python
# çº¿æ€§å›å½’çš„çŸ©é˜µå½¢å¼
np.random.seed(42)

# ç”Ÿæˆæ•°æ®
n_samples, n_features = 100, 3
X = np.random.randn(n_samples, n_features)
true_weights = np.array([1.5, -2.0, 0.5])
y = X @ true_weights + 0.1 * np.random.randn(n_samples)

# æ·»åŠ åç½®é¡¹
X_with_bias = np.column_stack([np.ones(n_samples), X])  # (100, 4)

# æ­£è§„æ–¹ç¨‹æ±‚è§£ï¼šw = (X^T X)^(-1) X^T y
# è¿™é‡Œæ¶‰åŠå¤šæ¬¡çŸ©é˜µä¹˜æ³•
XTX = X_with_bias.T @ X_with_bias      # (4, 100) @ (100, 4) = (4, 4)
XTy = X_with_bias.T @ y                # (4, 100) @ (100,) = (4,)
weights = np.linalg.inv(XTX) @ XTy     # (4, 4) @ (4,) = (4,)

print(f"çœŸå®æƒé‡: [bias, {true_weights}]")
print(f"ä¼°è®¡æƒé‡: {weights}")
print(f"è¯¯å·®: {np.abs(weights[1:] - true_weights)}")
```

### 3. ç¥ç»ç½‘ç»œå‰å‘ä¼ æ’­
```python
# ç®€å•ç¥ç»ç½‘ç»œçš„å‰å‘ä¼ æ’­
def relu(x):
    return np.maximum(0, x)

def forward_pass(X, W1, b1, W2, b2):
    """
    ä¸¤å±‚ç¥ç»ç½‘ç»œçš„å‰å‘ä¼ æ’­
    X: (batch_size, input_dim)
    W1: (input_dim, hidden_dim)
    W2: (hidden_dim, output_dim)
    """
    # ç¬¬ä¸€å±‚
    z1 = X @ W1 + b1      # (batch, input) @ (input, hidden) = (batch, hidden)
    a1 = relu(z1)         # æ¿€æ´»å‡½æ•°
    
    # ç¬¬äºŒå±‚
    z2 = a1 @ W2 + b2     # (batch, hidden) @ (hidden, output) = (batch, output)
    
    return z2

# ç¤ºä¾‹ç½‘ç»œ
batch_size, input_dim, hidden_dim, output_dim = 32, 10, 20, 1

X = np.random.randn(batch_size, input_dim)
W1 = np.random.randn(input_dim, hidden_dim) * 0.1
b1 = np.zeros(hidden_dim)
W2 = np.random.randn(hidden_dim, output_dim) * 0.1
b2 = np.zeros(output_dim)

output = forward_pass(X, W1, b1, W2, b2)

print(f"è¾“å…¥å½¢çŠ¶: {X.shape}")
print(f"W1å½¢çŠ¶: {W1.shape}")
print(f"W2å½¢çŠ¶: {W2.shape}")
print(f"è¾“å‡ºå½¢çŠ¶: {output.shape}")
```

---

## ğŸš€ é«˜çº§çŸ©é˜µä¹˜æ³•æŠ€å·§

### 1. æ‰¹é‡çŸ©é˜µä¹˜æ³•
```python
# æ‰¹é‡å¤„ç†å¤šä¸ªçŸ©é˜µä¹˜æ³•
batch_size = 10
n, m, p = 4, 5, 3

# æ‰¹é‡çŸ©é˜µ
A_batch = np.random.randn(batch_size, n, m)  # (10, 4, 5)
B_batch = np.random.randn(batch_size, m, p)  # (10, 5, 3)

# æ–¹æ³•1ï¼šå¾ªç¯ï¼ˆæ…¢ï¼‰
result_loop = np.zeros((batch_size, n, p))
for i in range(batch_size):
    result_loop[i] = A_batch[i] @ B_batch[i]

# æ–¹æ³•2ï¼šNumPyçš„batchedæ“ä½œï¼ˆå¿«ï¼‰
result_batch = A_batch @ B_batch  # è‡ªåŠ¨å¹¿æ’­æ‰¹é‡ç»´åº¦

print(f"æ‰¹é‡Aå½¢çŠ¶: {A_batch.shape}")
print(f"æ‰¹é‡Bå½¢çŠ¶: {B_batch.shape}")
print(f"æ‰¹é‡ç»“æœå½¢çŠ¶: {result_batch.shape}")
print(f"ç»“æœç›¸åŒ: {np.allclose(result_loop, result_batch)}")
```

### 2. çŸ©é˜µé“¾ä¹˜æ³•ä¼˜åŒ–
```python
# çŸ©é˜µé“¾ä¹˜æ³•ï¼šç»“åˆå¾‹çš„é‡è¦æ€§
A = np.random.randn(1000, 10)   # (1000, 10)
B = np.random.randn(10, 10)     # (10, 10)
C = np.random.randn(10, 1000)   # (10, 1000)

# è®¡ç®— A @ B @ Cï¼Œä¸¤ç§ç»“åˆæ–¹å¼
import time

# æ–¹å¼1ï¼š(A @ B) @ C
start = time.time()
result1 = (A @ B) @ C  # (1000, 10) @ (10, 1000) = (1000, 1000)
time1 = time.time() - start

# æ–¹å¼2ï¼šA @ (B @ C)
start = time.time()
result2 = A @ (B @ C)  # (1000, 10) @ (10, 1000) = (1000, 1000)
time2 = time.time() - start

print(f"æ–¹å¼1æ—¶é—´: {time1:.4f}ç§’")
print(f"æ–¹å¼2æ—¶é—´: {time2:.4f}ç§’")
print(f"é€Ÿåº¦å·®å¼‚: {time1/time2:.1f}å€")
print(f"ç»“æœç›¸åŒ: {np.allclose(result1, result2)}")

# åˆ†æè¿ç®—é‡
print("\nè¿ç®—é‡åˆ†æ:")
print(f"æ–¹å¼1: {1000*10*10} + {1000*10*1000} = {1000*10*10 + 1000*10*1000}")
print(f"æ–¹å¼2: {10*10*1000} + {1000*10*1000} = {10*10*1000 + 1000*10*1000}")
```

### 3. ç¨€ç–çŸ©é˜µä¹˜æ³•
```python
from scipy.sparse import csr_matrix

# åˆ›å»ºç¨€ç–çŸ©é˜µ
n, m, p = 1000, 1000, 1000
density = 0.01  # 1% çš„å…ƒç´ éé›¶

# å¯†é›†çŸ©é˜µ
A_dense = np.random.randn(n, m)
A_dense[np.random.rand(n, m) > density] = 0

B_dense = np.random.randn(m, p)
B_dense[np.random.rand(m, p) > density] = 0

# è½¬æ¢ä¸ºç¨€ç–çŸ©é˜µ
A_sparse = csr_matrix(A_dense)
B_sparse = csr_matrix(B_dense)

print(f"ç¨€ç–çŸ©é˜µA: {A_sparse.nnz} ä¸ªéé›¶å…ƒç´  / {n*m} æ€»å…ƒç´ ")
print(f"ç¨€ç–åº¦: {A_sparse.nnz/(n*m)*100:.2f}%")

# æ¯”è¾ƒå†…å­˜ä½¿ç”¨
print(f"å¯†é›†çŸ©é˜µå†…å­˜: {A_dense.nbytes + B_dense.nbytes} å­—èŠ‚")
print(f"ç¨€ç–çŸ©é˜µå†…å­˜: {A_sparse.data.nbytes + A_sparse.indices.nbytes + A_sparse.indptr.nbytes} å­—èŠ‚")
```

---

## ğŸ”§ æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### 1. å†…å­˜å¸ƒå±€ä¼˜åŒ–
```python
# C-contiguous vs Fortran-contiguous
n = 1000

# C-contiguous (è¡Œä¸»åº)
A_c = np.random.randn(n, n)
B_c = np.random.randn(n, n)

# Fortran-contiguous (åˆ—ä¸»åº)
A_f = np.asfortranarray(A_c)
B_f = np.asfortranarray(B_c)

# æµ‹è¯•æ€§èƒ½
import time

# C-contiguousçŸ©é˜µä¹˜æ³•
start = time.time()
C_c = A_c @ B_c
time_c = time.time() - start

# Fortran-contiguousçŸ©é˜µä¹˜æ³•
start = time.time()
C_f = A_f @ B_f
time_f = time.time() - start

print(f"C-contiguousæ—¶é—´: {time_c:.4f}ç§’")
print(f"Fortran-contiguousæ—¶é—´: {time_f:.4f}ç§’")
print(f"å†…å­˜å¸ƒå±€: A_cè¿ç»­={A_c.flags['C_CONTIGUOUS']}, A_fè¿ç»­={A_f.flags['F_CONTIGUOUS']}")
```

### 2. æ•°æ®ç±»å‹ä¼˜åŒ–
```python
# ä¸åŒç²¾åº¦çš„æ€§èƒ½æ¯”è¾ƒ
sizes = [500, 1000, 2000]
dtypes = [np.float32, np.float64]

for size in sizes:
    print(f"\nçŸ©é˜µå¤§å°: {size}x{size}")
    
    for dtype in dtypes:
        A = np.random.randn(size, size).astype(dtype)
        B = np.random.randn(size, size).astype(dtype)
        
        start = time.time()
        C = A @ B
        elapsed = time.time() - start
        
        print(f"{dtype.__name__}: {elapsed:.4f}ç§’, å†…å­˜: {A.nbytes + B.nbytes} å­—èŠ‚")
```

### 3. åˆ†å—çŸ©é˜µä¹˜æ³•
```python
def block_matrix_multiply(A, B, block_size=256):
    """åˆ†å—çŸ©é˜µä¹˜æ³•ï¼Œé€‚åˆå¤§çŸ©é˜µ"""
    m, n = A.shape
    n2, p = B.shape
    
    if n != n2:
        raise ValueError("çŸ©é˜µç»´åº¦ä¸åŒ¹é…")
    
    C = np.zeros((m, p))
    
    for i in range(0, m, block_size):
        for j in range(0, p, block_size):
            for k in range(0, n, block_size):
                # è·å–å—çš„è¾¹ç•Œ
                i_end = min(i + block_size, m)
                j_end = min(j + block_size, p)
                k_end = min(k + block_size, n)
                
                # å—ä¹˜æ³•
                C[i:i_end, j:j_end] += A[i:i_end, k:k_end] @ B[k:k_end, j:j_end]
    
    return C

# æµ‹è¯•å°çŸ©é˜µ
A_test = np.random.randn(100, 80)
B_test = np.random.randn(80, 60)

result_standard = A_test @ B_test
result_block = block_matrix_multiply(A_test, B_test, block_size=32)

print(f"åˆ†å—ç®—æ³•æ­£ç¡®æ€§: {np.allclose(result_standard, result_block)}")
```

---

## ğŸ§  çŸ©é˜µä¹˜æ³•çš„å‡ ä½•æ„ä¹‰

### 1. çº¿æ€§å˜æ¢çš„ç»„åˆ
```python
# ç»„åˆå˜æ¢ï¼šå…ˆç¼©æ”¾åæ—‹è½¬
scale_matrix = np.array([[2, 0],
                        [0, 0.5]])  # xè½´æ”¾å¤§2å€ï¼Œyè½´ç¼©å°2å€

rotation_matrix = np.array([[np.cos(np.pi/4), -np.sin(np.pi/4)],
                           [np.sin(np.pi/4), np.cos(np.pi/4)]])  # é€†æ—¶é’ˆæ—‹è½¬45åº¦

# ç»„åˆå˜æ¢çŸ©é˜µ
combined_transform = rotation_matrix @ scale_matrix

# æµ‹è¯•ç‚¹
original_point = np.array([1, 1])

# åˆ†æ­¥å˜æ¢
scaled_point = scale_matrix @ original_point
final_point_step = rotation_matrix @ scaled_point

# ä¸€æ­¥å˜æ¢
final_point_combined = combined_transform @ original_point

print(f"åŸå§‹ç‚¹: {original_point}")
print(f"åˆ†æ­¥å˜æ¢: {original_point} -> {scaled_point} -> {final_point_step}")
print(f"ç»„åˆå˜æ¢: {original_point} -> {final_point_combined}")
print(f"ç»“æœç›¸åŒ: {np.allclose(final_point_step, final_point_combined)}")
```

### 2. åŸºå˜æ¢
```python
# åæ ‡ç³»å˜æ¢
# æ ‡å‡†åŸº
standard_basis = np.array([[1, 0],
                          [0, 1]])

# æ–°åŸºï¼š45åº¦æ—‹è½¬çš„åæ ‡ç³»
new_basis = np.array([[1/np.sqrt(2), 1/np.sqrt(2)],
                     [-1/np.sqrt(2), 1/np.sqrt(2)]])

# ç‚¹åœ¨æ ‡å‡†åæ ‡ç³»ä¸­çš„è¡¨ç¤º
point_standard = np.array([3, 4])

# è½¬æ¢åˆ°æ–°åæ ‡ç³»
# éœ€è¦ç”¨æ–°åŸºçš„é€†çŸ©é˜µï¼ˆè½¬ç½®ï¼Œå› ä¸ºæ˜¯æ­£äº¤çŸ©é˜µï¼‰
point_new = new_basis.T @ point_standard

print(f"æ ‡å‡†åæ ‡ç³»ä¸­çš„ç‚¹: {point_standard}")
print(f"æ–°åæ ‡ç³»ä¸­çš„ç‚¹: {point_new}")

# éªŒè¯ï¼šè½¬æ¢å›æ ‡å‡†åæ ‡ç³»
point_back = new_basis @ point_new
print(f"è½¬æ¢å›æ ‡å‡†åæ ‡ç³»: {point_back}")
print(f"è½¬æ¢æ­£ç¡®: {np.allclose(point_standard, point_back)}")
```

---

## ğŸ¯ å®æˆ˜æ¡ˆä¾‹åˆ†æ

### æ¡ˆä¾‹1ï¼šå›¾åƒå·ç§¯çš„çŸ©é˜µè¡¨ç¤º
```python
def convolution_as_matrix(image_size, kernel_size):
    """å°†å·ç§¯æ“ä½œè¡¨ç¤ºä¸ºçŸ©é˜µä¹˜æ³•"""
    h, w = image_size
    kh, kw = kernel_size
    
    # è¾“å‡ºå¤§å°ï¼ˆå‡è®¾stride=1, padding=0ï¼‰
    out_h, out_w = h - kh + 1, w - kw + 1
    
    # åˆ›å»ºå·ç§¯çŸ©é˜µ
    conv_matrix = np.zeros((out_h * out_w, h * w))
    
    for i in range(out_h):
        for j in range(out_w):
            output_idx = i * out_w + j
            
            for ki in range(kh):
                for kj in range(kw):
                    input_i = i + ki
                    input_j = j + kj
                    input_idx = input_i * w + input_j
                    
                    conv_matrix[output_idx, input_idx] = 1  # ç®€åŒ–çš„kernelæƒé‡
    
    return conv_matrix

# æµ‹è¯•
image_size = (4, 4)
kernel_size = (3, 3)
conv_mat = convolution_as_matrix(image_size, kernel_size)

print(f"å›¾åƒå¤§å°: {image_size}")
print(f"å·ç§¯æ ¸å¤§å°: {kernel_size}")
print(f"å·ç§¯çŸ©é˜µå½¢çŠ¶: {conv_mat.shape}")
print(f"è¾“å‡ºå¤§å°: {conv_mat.shape[0]} = {2*2}")

# æ¨¡æ‹Ÿå›¾åƒ
image = np.random.randn(16)  # 4x4å›¾åƒå±•å¹³
output = conv_mat @ image    # çŸ©é˜µä¹˜æ³•æ‰§è¡Œå·ç§¯

print(f"è¾“å…¥å›¾åƒ: {image.shape}")
print(f"è¾“å‡ºç‰¹å¾: {output.shape}")
```

### æ¡ˆä¾‹2ï¼šæ³¨æ„åŠ›æœºåˆ¶
```python
def attention_mechanism(Q, K, V):
    """
    Attention(Q,K,V) = softmax(QK^T / âˆšd_k)V
    Q: æŸ¥è¯¢çŸ©é˜µ (seq_len, d_model)
    K: é”®çŸ©é˜µ (seq_len, d_model)  
    V: å€¼çŸ©é˜µ (seq_len, d_model)
    """
    d_k = K.shape[-1]
    
    # è®¡ç®—æ³¨æ„åŠ›åˆ†æ•°
    scores = Q @ K.T / np.sqrt(d_k)  # (seq_len, seq_len)
    
    # Softmax
    exp_scores = np.exp(scores - np.max(scores, axis=-1, keepdims=True))
    attention_weights = exp_scores / np.sum(exp_scores, axis=-1, keepdims=True)
    
    # åŠ æƒæ±‚å’Œ
    output = attention_weights @ V  # (seq_len, d_model)
    
    return output, attention_weights

# ç¤ºä¾‹ï¼šåºåˆ—é•¿åº¦4ï¼Œç‰¹å¾ç»´åº¦8
seq_len, d_model = 4, 8
Q = np.random.randn(seq_len, d_model)
K = np.random.randn(seq_len, d_model)
V = np.random.randn(seq_len, d_model)

output, weights = attention_mechanism(Q, K, V)

print(f"Qå½¢çŠ¶: {Q.shape}")
print(f"Kå½¢çŠ¶: {K.shape}")
print(f"Vå½¢çŠ¶: {V.shape}")
print(f"æ³¨æ„åŠ›æƒé‡å½¢çŠ¶: {weights.shape}")
print(f"è¾“å‡ºå½¢çŠ¶: {output.shape}")
print(f"æ³¨æ„åŠ›æƒé‡å’Œ: {weights.sum(axis=1)}")  # æ¯è¡Œå’Œä¸º1
```

### æ¡ˆä¾‹3ï¼šPageRankç®—æ³•
```python
def pagerank(adjacency_matrix, damping_factor=0.85, max_iter=100, tol=1e-6):
    """
    PageRankç®—æ³•çš„çŸ©é˜µå®ç°
    """
    n = adjacency_matrix.shape[0]
    
    # è½¬æ¢ä¸ºè½¬ç§»æ¦‚ç‡çŸ©é˜µ
    # å‡ºåº¦
    out_degrees = adjacency_matrix.sum(axis=1)
    out_degrees[out_degrees == 0] = 1  # é¿å…é™¤é›¶
    
    # è½¬ç§»çŸ©é˜µ
    transition_matrix = adjacency_matrix / out_degrees[:, np.newaxis]
    
    # PageRankçŸ©é˜µ
    # PR = (1-d)/n * ones + d * M^T * PR
    ones_vector = np.ones(n) / n
    
    # åˆå§‹PageRankå€¼
    pagerank_vector = np.ones(n) / n
    
    for iteration in range(max_iter):
        new_pagerank = ((1 - damping_factor) / n + 
                       damping_factor * (transition_matrix.T @ pagerank_vector))
        
        # æ£€æŸ¥æ”¶æ•›
        if np.linalg.norm(new_pagerank - pagerank_vector) < tol:
            print(f"æ”¶æ•›äºç¬¬ {iteration + 1} æ¬¡è¿­ä»£")
            break
            
        pagerank_vector = new_pagerank
    
    return pagerank_vector

# ç¤ºä¾‹ç½‘ç»œï¼š4ä¸ªèŠ‚ç‚¹
# 0 -> 1, 2
# 1 -> 2
# 2 -> 0, 1
# 3 -> 0, 1, 2
adjacency = np.array([[0, 1, 1, 0],
                     [0, 0, 1, 0],
                     [1, 1, 0, 0],
                     [1, 1, 1, 0]])

pr_scores = pagerank(adjacency)

print("PageRank åˆ†æ•°:")
for i, score in enumerate(pr_scores):
    print(f"èŠ‚ç‚¹ {i}: {score:.4f}")
print(f"æ€»å’Œ: {pr_scores.sum():.4f}")
```

---

## ğŸ“š æ€»ç»“ä¸å»ºè®®

### çŸ©é˜µä¹˜æ³•çš„é‡è¦æ€§
1. **æ•°æ®å˜æ¢**ï¼šæ‰€æœ‰çº¿æ€§å˜æ¢çš„åŸºç¡€
2. **ç®—æ³•æ ¸å¿ƒ**ï¼šæœºå™¨å­¦ä¹ ç®—æ³•çš„è®¡ç®—åŸºçŸ³
3. **æ•ˆç‡å…³é”®**ï¼šé«˜æ€§èƒ½è®¡ç®—çš„ç“¶é¢ˆæ‰€åœ¨
4. **ç†è®ºæ¡¥æ¢**ï¼šè¿æ¥æŠ½è±¡æ¦‚å¿µä¸å®é™…è®¡ç®—

### æŒæ¡è¦ç‚¹
1. **å‡ ä½•ç›´è§‰**ï¼šç†è§£çº¿æ€§å˜æ¢çš„å«ä¹‰
2. **è®¡ç®—è§„åˆ™**ï¼šç†Ÿç»ƒæŒæ¡ç»´åº¦åŒ¹é…
3. **ä¼˜åŒ–ç­–ç•¥**ï¼šäº†è§£æ€§èƒ½ä¼˜åŒ–æŠ€å·§
4. **åº”ç”¨åœºæ™¯**ï¼šè®¤è¯†åœ¨MLä¸­çš„ä½œç”¨

### å­¦ä¹ å»ºè®®
1. **æ‰‹å·¥è®¡ç®—**ï¼šå…ˆæ‰‹ç®—å°çŸ©é˜µï¼Œå»ºç«‹ç›´è§‰
2. **å¯è§†åŒ–**ï¼šç”»å›¾ç†è§£å‡ ä½•å˜æ¢
3. **æ€§èƒ½åˆ†æ**ï¼šæµ‹è¯•ä¸åŒå®ç°çš„æ•ˆç‡
4. **å®é™…åº”ç”¨**ï¼šåœ¨é¡¹ç›®ä¸­åº”ç”¨çŸ©é˜µä¹˜æ³•

### å¸¸è§é”™è¯¯
1. **ç»´åº¦é”™è¯¯**ï¼šä¸æ£€æŸ¥çŸ©é˜µå½¢çŠ¶å…¼å®¹æ€§
2. **å†…å­˜é—®é¢˜**ï¼šå¤§çŸ©é˜µè¿ç®—å¯¼è‡´å†…å­˜ä¸è¶³
3. **ç²¾åº¦æŸå¤±**ï¼šä¸å½“çš„æ•°æ®ç±»å‹é€‰æ‹©
4. **æ•ˆç‡ä½ä¸‹**ï¼šå¿½ç•¥è¿ç®—é¡ºåºå’Œå†…å­˜å¸ƒå±€

### ä¸‹ä¸€æ­¥å­¦ä¹ 
- ç‰¹å¾å€¼åˆ†è§£ä¸SVD
- çŸ©é˜µæ±‚å¯¼ä¸åå‘ä¼ æ’­
- åˆ†å¸ƒå¼çŸ©é˜µè¿ç®—
- GPUåŠ é€Ÿçš„çŸ©é˜µè¿ç®—

---

**âš¡ è®°ä½ï¼šçŸ©é˜µä¹˜æ³•æ˜¯æ•°æ®ç§‘å­¦çš„è¯­è¨€ï¼ŒæŒæ¡å®ƒå°±æŒæ¡äº†ä¸æ•°æ®å¯¹è¯çš„èƒ½åŠ›ï¼** 