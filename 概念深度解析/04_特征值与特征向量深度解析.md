# ğŸ­ ç‰¹å¾å€¼ä¸ç‰¹å¾å‘é‡æ·±åº¦è§£æ

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

> **ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡æ­ç¤ºäº†çŸ©é˜µå˜æ¢çš„æœ¬è´¨æ–¹å‘å’Œå¼ºåº¦ï¼Œæ˜¯ç†è§£æ•°æ®ç»“æ„çš„é’¥åŒ™**

### ä»€ä¹ˆæ˜¯ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡ï¼Ÿ
**å®šä¹‰**ï¼šå¯¹äºæ–¹é˜µAï¼Œå¦‚æœå­˜åœ¨éé›¶å‘é‡vå’Œæ ‡é‡Î»ï¼Œä½¿å¾— Av = Î»vï¼Œé‚£ä¹ˆï¼š
- Î»æ˜¯Açš„**ç‰¹å¾å€¼**
- væ˜¯å¯¹åº”çš„**ç‰¹å¾å‘é‡**

**æ ¸å¿ƒæ€æƒ³**ï¼šç‰¹å¾å‘é‡æ˜¯çŸ©é˜µå˜æ¢åæ–¹å‘ä¸å˜çš„å‘é‡ï¼Œç‰¹å¾å€¼æ˜¯åœ¨è¯¥æ–¹å‘ä¸Šçš„æ‹‰ä¼¸å€æ•°ã€‚

---

## ğŸ§  ç›´è§‰ç†è§£

### å‡ ä½•æ„ä¹‰
```python
import numpy as np
import matplotlib.pyplot as plt

# åˆ›å»ºä¸€ä¸ªç®€å•çš„2x2çŸ©é˜µ
A = np.array([[3, 1],
              [0, 2]])

# è®¡ç®—ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡
eigenvalues, eigenvectors = np.linalg.eig(A)

print("çŸ©é˜µA:")
print(A)
print(f"\nç‰¹å¾å€¼: {eigenvalues}")
print(f"ç‰¹å¾å‘é‡:\n{eigenvectors}")

# éªŒè¯ç‰¹å¾å€¼å®šä¹‰
for i in range(len(eigenvalues)):
    Î» = eigenvalues[i]
    v = eigenvectors[:, i]
    
    Av = A @ v
    Î»v = Î» * v
    
    print(f"\nç‰¹å¾å€¼ {i+1}: Î» = {Î»:.3f}")
    print(f"ç‰¹å¾å‘é‡: v = {v}")
    print(f"Av = {Av}")
    print(f"Î»v = {Î»v}")
    print(f"Av = Î»v? {np.allclose(Av, Î»v)}")
```

### å¯è§†åŒ–ç‰¹å¾å‘é‡
```python
def visualize_eigenvectors(A):
    """å¯è§†åŒ–ç‰¹å¾å‘é‡åœ¨å˜æ¢ä¸­çš„ä¸å˜æ€§"""
    # è®¡ç®—ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡
    eigenvalues, eigenvectors = np.linalg.eig(A)
    
    # åˆ›å»ºä¸€äº›æµ‹è¯•å‘é‡
    test_vectors = np.array([[1, 0], [0, 1], [1, 1], [1, -1]]).T
    
    # å˜æ¢åçš„å‘é‡
    transformed_vectors = A @ test_vectors
    
    print("å˜æ¢å‰åçš„å‘é‡:")
    for i in range(test_vectors.shape[1]):
        v_before = test_vectors[:, i]
        v_after = transformed_vectors[:, i]
        print(f"å‘é‡ {i+1}: {v_before} -> {v_after}")
    
    print(f"\nç‰¹å¾å‘é‡ï¼ˆæ–¹å‘ä¸å˜ï¼‰:")
    for i in range(len(eigenvalues)):
        Î» = eigenvalues[i]
        v = eigenvectors[:, i]
        transformed_v = A @ v
        print(f"ç‰¹å¾å‘é‡ {i+1}: {v} -> {transformed_v} (ç¼©æ”¾ {Î»:.3f}å€)")

# æµ‹è¯•
A = np.array([[3, 1], [0, 2]])
visualize_eigenvectors(A)
```

---

## ğŸ”¢ ç‰¹å¾å€¼åˆ†è§£è¯¦è§£

### ç‰¹å¾å€¼æ–¹ç¨‹çš„æ±‚è§£
```python
def solve_eigenvalue_equation_manual(A):
    """æ‰‹åŠ¨æ±‚è§£ç‰¹å¾å€¼æ–¹ç¨‹ det(A - Î»I) = 0"""
    print("æ±‚è§£ç‰¹å¾å€¼æ–¹ç¨‹ï¼šdet(A - Î»I) = 0")
    print(f"çŸ©é˜µA:\n{A}")
    
    # å¯¹äº2x2çŸ©é˜µï¼Œç‰¹å¾å¤šé¡¹å¼æ˜¯ï¼šÎ»Â² - trace(A)Î» + det(A) = 0
    if A.shape == (2, 2):
        trace_A = np.trace(A)  # å¯¹è§’çº¿å…ƒç´ ä¹‹å’Œ
        det_A = np.linalg.det(A)  # è¡Œåˆ—å¼
        
        print(f"è¿¹(trace): {trace_A}")
        print(f"è¡Œåˆ—å¼(det): {det_A}")
        print(f"ç‰¹å¾å¤šé¡¹å¼: Î»Â² - {trace_A}Î» + {det_A} = 0")
        
        # ä½¿ç”¨äºŒæ¬¡å…¬å¼æ±‚è§£
        discriminant = trace_A**2 - 4*det_A
        Î»1 = (trace_A + np.sqrt(discriminant)) / 2
        Î»2 = (trace_A - np.sqrt(discriminant)) / 2
        
        print(f"ç‰¹å¾å€¼: Î»1 = {Î»1:.3f}, Î»2 = {Î»2:.3f}")
        
        # éªŒè¯
        Î»_numpy, _ = np.linalg.eig(A)
        print(f"NumPyç»“æœ: {np.sort(Î»_numpy)}")
        print(f"æ‰‹åŠ¨è®¡ç®—ç»“æœ: {np.sort([Î»1, Î»2])}")

# æµ‹è¯•
A = np.array([[4, 2], [1, 3]])
solve_eigenvalue_equation_manual(A)
```

### ç‰¹å¾å‘é‡çš„è®¡ç®—
```python
def find_eigenvectors_manual(A, eigenvalue):
    """æ‰‹åŠ¨è®¡ç®—ç»™å®šç‰¹å¾å€¼çš„ç‰¹å¾å‘é‡"""
    print(f"\nè®¡ç®—ç‰¹å¾å€¼ Î» = {eigenvalue} çš„ç‰¹å¾å‘é‡")
    
    # æ„é€  (A - Î»I)
    I = np.eye(A.shape[0])
    matrix = A - eigenvalue * I
    
    print(f"A - Î»I =")
    print(matrix)
    
    # æ±‚è§£ (A - Î»I)v = 0
    # è¿™ç­‰ä»·äºæ±‚è§£é½æ¬¡çº¿æ€§æ–¹ç¨‹ç»„
    print(f"æ±‚è§£ (A - Î»I)v = 0")
    
    # å¯¹äº2x2çŸ©é˜µçš„ç‰¹æ®Šæƒ…å†µ
    if A.shape == (2, 2):
        a, b = matrix[0]
        c, d = matrix[1]
        
        if abs(a) > 1e-10:  # a â‰  0
            # ä»ç¬¬ä¸€è¡Œï¼ša*x + b*y = 0 => x = -b*y/a
            v = np.array([-b, a])
        elif abs(c) > 1e-10:  # c â‰  0
            # ä»ç¬¬äºŒè¡Œï¼šc*x + d*y = 0 => x = -d*y/c
            v = np.array([-d, c])
        else:
            # ç‰¹æ®Šæƒ…å†µ
            v = np.array([1, 0])
        
        # æ ‡å‡†åŒ–
        v = v / np.linalg.norm(v)
        
        print(f"ç‰¹å¾å‘é‡: {v}")
        
        # éªŒè¯
        result = A @ v
        expected = eigenvalue * v
        print(f"éªŒè¯: Av = {result}")
        print(f"Î»v = {expected}")
        print(f"è¯¯å·®: {np.linalg.norm(result - expected):.6f}")
        
        return v

# æµ‹è¯•
A = np.array([[3, 1], [0, 2]])
eigenvalues, _ = np.linalg.eig(A)
for Î» in eigenvalues:
    find_eigenvectors_manual(A, Î»)
```

---

## ğŸ¯ ç‰¹å¾å€¼åˆ†è§£çš„åº”ç”¨

### 1. ä¸»æˆåˆ†åˆ†æ(PCA)é¢„è§ˆ
```python
def pca_preview_with_eigenvalues():
    """å±•ç¤ºç‰¹å¾å€¼åœ¨PCAä¸­çš„ä½œç”¨"""
    # ç”Ÿæˆ2Dæ•°æ®ï¼šæ¤­åœ†åˆ†å¸ƒ
    np.random.seed(42)
    
    # åŸå§‹æ•°æ®
    data = np.random.randn(100, 2)
    
    # æ–½åŠ ä¸€ä¸ªå˜æ¢ï¼Œåˆ›é€ ç›¸å…³æ€§
    transform = np.array([[2, 1], [1, 1]])
    transformed_data = data @ transform.T
    
    # ä¸­å¿ƒåŒ–æ•°æ®
    centered_data = transformed_data - np.mean(transformed_data, axis=0)
    
    # è®¡ç®—åæ–¹å·®çŸ©é˜µ
    cov_matrix = np.cov(centered_data.T)
    
    # ç‰¹å¾å€¼åˆ†è§£
    eigenvalues, eigenvectors = np.linalg.eig(cov_matrix)
    
    # æŒ‰ç‰¹å¾å€¼å¤§å°æ’åº
    idx = np.argsort(eigenvalues)[::-1]
    eigenvalues = eigenvalues[idx]
    eigenvectors = eigenvectors[:, idx]
    
    print("åæ–¹å·®çŸ©é˜µ:")
    print(cov_matrix)
    print(f"\nç‰¹å¾å€¼: {eigenvalues}")
    print(f"ç‰¹å¾å€¼æ¯”ä¾‹: {eigenvalues / eigenvalues.sum()}")
    print(f"\nç‰¹å¾å‘é‡ï¼ˆä¸»æˆåˆ†æ–¹å‘ï¼‰:")
    print(eigenvectors)
    
    # è§£é‡Šæ–¹å·®æ¯”ä¾‹
    explained_variance_ratio = eigenvalues / eigenvalues.sum()
    print(f"\nè§£é‡Šæ–¹å·®æ¯”ä¾‹:")
    for i, ratio in enumerate(explained_variance_ratio):
        print(f"PC{i+1}: {ratio:.2%}")
    
    return eigenvalues, eigenvectors, centered_data

eigenvals, eigenvecs, data = pca_preview_with_eigenvalues()
```

### 2. çŸ©é˜µå¹‚è¿ç®—
```python
def matrix_power_using_eigendecomposition(A, n):
    """ä½¿ç”¨ç‰¹å¾å€¼åˆ†è§£è®¡ç®—çŸ©é˜µçš„å¹‚"""
    # ç‰¹å¾å€¼åˆ†è§£ï¼šA = QÎ›Qâ»Â¹
    eigenvalues, eigenvectors = np.linalg.eig(A)
    
    # A^n = Q Î›^n Qâ»Â¹
    Q = eigenvectors
    Q_inv = np.linalg.inv(Q)
    Lambda_n = np.diag(eigenvalues ** n)
    
    A_n = Q @ Lambda_n @ Q_inv
    
    # éªŒè¯
    A_n_direct = np.linalg.matrix_power(A, n)
    
    print(f"çŸ©é˜µA:\n{A}")
    print(f"\nA^{n} (ç‰¹å¾å€¼åˆ†è§£):\n{A_n.real}")
    print(f"\nA^{n} (ç›´æ¥è®¡ç®—):\n{A_n_direct}")
    print(f"\nè¯¯å·®: {np.linalg.norm(A_n.real - A_n_direct):.6f}")
    
    return A_n

# æµ‹è¯•
A = np.array([[2, 1], [1, 2]])
A_5 = matrix_power_using_eigendecomposition(A, 5)
```

### 3. çº¿æ€§ç³»ç»Ÿçš„ç¨³å®šæ€§åˆ†æ
```python
def analyze_system_stability(A):
    """åˆ†æçº¿æ€§åŠ¨æ€ç³»ç»Ÿçš„ç¨³å®šæ€§"""
    eigenvalues, eigenvectors = np.linalg.eig(A)
    
    print("çº¿æ€§ç³»ç»Ÿ dx/dt = Ax çš„ç¨³å®šæ€§åˆ†æ")
    print(f"ç³»ç»ŸçŸ©é˜µA:\n{A}")
    print(f"\nç‰¹å¾å€¼: {eigenvalues}")
    
    # ç¨³å®šæ€§åˆ¤æ–­
    real_parts = eigenvalues.real
    
    if all(real_parts < 0):
        stability = "ç¨³å®š (æ‰€æœ‰ç‰¹å¾å€¼å®éƒ¨ä¸ºè´Ÿ)"
    elif all(real_parts <= 0) and all(eigenvalues.imag == 0):
        stability = "è¾¹ç•Œç¨³å®š (æ‰€æœ‰ç‰¹å¾å€¼å®éƒ¨éæ­£)"
    else:
        stability = "ä¸ç¨³å®š (å­˜åœ¨æ­£å®éƒ¨ç‰¹å¾å€¼)"
    
    print(f"\nç¨³å®šæ€§: {stability}")
    
    # æ¨¡æ‹Ÿç³»ç»Ÿæ¼”åŒ–
    def simulate_system(x0, t_max=5, dt=0.1):
        """æ¨¡æ‹Ÿç³»ç»Ÿæ¼”åŒ–"""
        t = np.arange(0, t_max, dt)
        trajectory = np.zeros((len(t), len(x0)))
        trajectory[0] = x0
        
        for i in range(1, len(t)):
            # ä½¿ç”¨çŸ©é˜µæŒ‡æ•°ï¼šx(t) = e^(At) x(0)
            # è¿‘ä¼¼ï¼šx(t+dt) â‰ˆ (I + A*dt) x(t)
            trajectory[i] = (np.eye(len(x0)) + A * dt) @ trajectory[i-1]
        
        return t, trajectory
    
    # æµ‹è¯•ä¸åŒåˆå§‹æ¡ä»¶
    initial_conditions = [[1, 0], [0, 1], [1, 1]]
    
    for i, x0 in enumerate(initial_conditions):
        t, traj = simulate_system(x0)
        final_state = traj[-1]
        print(f"\nåˆå§‹æ¡ä»¶ {x0}: æœ€ç»ˆçŠ¶æ€ {final_state} (æ¨¡é•¿: {np.linalg.norm(final_state):.3f})")

# æµ‹è¯•ä¸åŒç±»å‹çš„ç³»ç»Ÿ
print("=== ç¨³å®šç³»ç»Ÿ ===")
A_stable = np.array([[-1, 0.5], [-0.5, -2]])
analyze_system_stability(A_stable)

print("\n=== ä¸ç¨³å®šç³»ç»Ÿ ===")
A_unstable = np.array([[1, 0.5], [-0.5, 0.5]])
analyze_system_stability(A_unstable)
```

---

## ğŸš€ é«˜çº§ç‰¹å¾å€¼åˆ†æ

### 1. å¯¹ç§°çŸ©é˜µçš„ç‰¹æ®Šæ€§è´¨
```python
def analyze_symmetric_matrix():
    """åˆ†æå¯¹ç§°çŸ©é˜µçš„ç‰¹å¾å€¼æ€§è´¨"""
    # åˆ›å»ºå¯¹ç§°çŸ©é˜µ
    A = np.array([[4, 2, 1],
                  [2, 3, 0],
                  [1, 0, 2]])
    
    print("å¯¹ç§°çŸ©é˜µçš„ç‰¹å¾å€¼åˆ†æ")
    print(f"çŸ©é˜µA:\n{A}")
    print(f"æ˜¯å¦å¯¹ç§°: {np.allclose(A, A.T)}")
    
    # ç‰¹å¾å€¼åˆ†è§£
    eigenvalues, eigenvectors = np.linalg.eig(A)
    
    print(f"\nç‰¹å¾å€¼: {eigenvalues}")
    print(f"æ‰€æœ‰ç‰¹å¾å€¼éƒ½æ˜¯å®æ•°: {np.allclose(eigenvalues.imag, 0)}")
    
    print(f"\nç‰¹å¾å‘é‡:\n{eigenvectors}")
    
    # æ£€æŸ¥æ­£äº¤æ€§
    dot_products = []
    for i in range(len(eigenvalues)):
        for j in range(i+1, len(eigenvalues)):
            dot_prod = np.dot(eigenvectors[:, i], eigenvectors[:, j])
            dot_products.append(dot_prod)
            print(f"v{i+1} Â· v{j+1} = {dot_prod:.6f}")
    
    print(f"ç‰¹å¾å‘é‡æ­£äº¤: {all(abs(dp) < 1e-10 for dp in dot_products)}")
    
    # è°±åˆ†è§£ï¼šA = QÎ›Q^T
    Q = eigenvectors
    Lambda = np.diag(eigenvalues)
    A_reconstructed = Q @ Lambda @ Q.T
    
    print(f"\né‡æ„è¯¯å·®: {np.linalg.norm(A - A_reconstructed):.6f}")

analyze_symmetric_matrix()
```

### 2. æ¡ä»¶æ•°ä¸æ•°å€¼ç¨³å®šæ€§
```python
def analyze_condition_number():
    """åˆ†ææ¡ä»¶æ•°å¯¹æ•°å€¼ç¨³å®šæ€§çš„å½±å“"""
    
    # åˆ›å»ºä¸åŒæ¡ä»¶æ•°çš„çŸ©é˜µ
    matrices = {
        "è‰¯æ¡ä»¶": np.array([[4, 0], [0, 3]]),
        "ä¸­ç­‰æ¡ä»¶": np.array([[4, 1], [1, 3]]),
        "ç—…æ€": np.array([[4, 3.99], [3.99, 4]])
    }
    
    for name, A in matrices.items():
        print(f"\n=== {name}çŸ©é˜µ ===")
        print(f"çŸ©é˜µA:\n{A}")
        
        # è®¡ç®—ç‰¹å¾å€¼
        eigenvalues = np.linalg.eigvals(A)
        
        # æ¡ä»¶æ•°
        cond_num = np.linalg.cond(A)
        
        # ç‰¹å¾å€¼æ¡ä»¶æ•°
        eigenvalue_ratio = max(eigenvalues) / min(eigenvalues)
        
        print(f"ç‰¹å¾å€¼: {eigenvalues}")
        print(f"æ¡ä»¶æ•°: {cond_num:.2f}")
        print(f"ç‰¹å¾å€¼æ¯”å€¼: {eigenvalue_ratio:.2f}")
        
        # æµ‹è¯•æ•°å€¼ç¨³å®šæ€§
        # æ·»åŠ å°æ‰°åŠ¨
        perturbation = 1e-10 * np.random.randn(*A.shape)
        A_perturbed = A + perturbation
        
        eigenvalues_perturbed = np.linalg.eigvals(A_perturbed)
        
        eigenvalue_change = np.abs(eigenvalues - eigenvalues_perturbed)
        relative_change = eigenvalue_change / np.abs(eigenvalues)
        
        print(f"æ‰°åŠ¨ä¸‹ç‰¹å¾å€¼å˜åŒ–: {eigenvalue_change}")
        print(f"ç›¸å¯¹å˜åŒ–: {relative_change}")

analyze_condition_number()
```

### 3. å¹¿ä¹‰ç‰¹å¾å€¼é—®é¢˜
```python
def generalized_eigenvalue_problem():
    """æ±‚è§£å¹¿ä¹‰ç‰¹å¾å€¼é—®é¢˜ Av = Î»Bv"""
    
    # åˆ›å»ºçŸ©é˜µAå’ŒB
    A = np.array([[2, 1], [1, 3]])
    B = np.array([[1, 0.5], [0.5, 2]])
    
    print("å¹¿ä¹‰ç‰¹å¾å€¼é—®é¢˜: Av = Î»Bv")
    print(f"çŸ©é˜µA:\n{A}")
    print(f"çŸ©é˜µB:\n{B}")
    
    # æ–¹æ³•1ï¼šä½¿ç”¨scipy
    from scipy.linalg import eig
    eigenvalues, eigenvectors = eig(A, B)
    
    print(f"\nå¹¿ä¹‰ç‰¹å¾å€¼: {eigenvalues}")
    print(f"å¹¿ä¹‰ç‰¹å¾å‘é‡:\n{eigenvectors}")
    
    # éªŒè¯
    for i in range(len(eigenvalues)):
        Î» = eigenvalues[i]
        v = eigenvectors[:, i]
        
        Av = A @ v
        Bv = B @ v
        Î»Bv = Î» * Bv
        
        error = np.linalg.norm(Av - Î»Bv)
        print(f"\nç‰¹å¾å€¼ {i+1}: Î» = {Î»:.3f}")
        print(f"||Av - Î»Bv|| = {error:.6f}")
    
    # æ–¹æ³•2ï¼šè½¬æ¢ä¸ºæ ‡å‡†ç‰¹å¾å€¼é—®é¢˜
    # Av = Î»Bv => B^(-1)Av = Î»v
    B_inv = np.linalg.inv(B)
    C = B_inv @ A
    
    eigenvalues_std, eigenvectors_std = np.linalg.eig(C)
    
    print(f"\nè½¬æ¢åçš„æ ‡å‡†ç‰¹å¾å€¼: {eigenvalues_std}")
    print(f"æ¯”è¾ƒ: {np.allclose(np.sort(eigenvalues.real), np.sort(eigenvalues_std.real))}")

generalized_eigenvalue_problem()
```

---

## ğŸ¨ ç‰¹å¾å€¼çš„å‡ ä½•è§£é‡Š

### 1. æ¤­åœ†çš„ä¸»è½´
```python
def ellipse_principal_axes():
    """ç”¨ç‰¹å¾å€¼åˆ†ææ¤­åœ†çš„ä¸»è½´"""
    
    # æ¤­åœ†æ–¹ç¨‹çš„äºŒæ¬¡å‹çŸ©é˜µ
    # x^T A x = 1 è¡¨ç¤ºæ¤­åœ†
    A = np.array([[5, 3], [3, 2]])
    
    print("æ¤­åœ†åˆ†æ: x^T A x = 1")
    print(f"äºŒæ¬¡å‹çŸ©é˜µA:\n{A}")
    
    # ç‰¹å¾å€¼åˆ†è§£
    eigenvalues, eigenvectors = np.linalg.eig(A)
    
    # æŒ‰ç‰¹å¾å€¼å¤§å°æ’åº
    idx = np.argsort(eigenvalues)[::-1]
    eigenvalues = eigenvalues[idx]
    eigenvectors = eigenvectors[:, idx]
    
    print(f"\nç‰¹å¾å€¼: {eigenvalues}")
    print(f"ç‰¹å¾å‘é‡ï¼ˆä¸»è½´æ–¹å‘ï¼‰:\n{eigenvectors}")
    
    # æ¤­åœ†çš„åŠè½´é•¿åº¦
    semi_axes = 1 / np.sqrt(eigenvalues)
    
    print(f"\næ¤­åœ†åŠè½´é•¿åº¦:")
    print(f"é•¿è½´: {semi_axes[0]:.3f}")
    print(f"çŸ­è½´: {semi_axes[1]:.3f}")
    
    # ä¸»è½´è§’åº¦
    angle = np.arctan2(eigenvectors[1, 0], eigenvectors[0, 0])
    angle_degrees = np.degrees(angle)
    
    print(f"ä¸»è½´è§’åº¦: {angle_degrees:.2f}Â°")
    
    # ç”Ÿæˆæ¤­åœ†ä¸Šçš„ç‚¹
    t = np.linspace(0, 2*np.pi, 100)
    
    # åœ¨ç‰¹å¾å‘é‡åæ ‡ç³»ä¸­çš„æ ‡å‡†æ¤­åœ†
    standard_ellipse = np.array([semi_axes[0] * np.cos(t),
                                semi_axes[1] * np.sin(t)])
    
    # å˜æ¢å›åŸåæ ‡ç³»
    ellipse_points = eigenvectors @ standard_ellipse
    
    print(f"\næ¤­åœ†å‚æ•°åŒ–å®Œæˆï¼Œç”Ÿæˆäº† {len(t)} ä¸ªç‚¹")

ellipse_principal_axes()
```

### 2. åæ–¹å·®çŸ©é˜µçš„å‡ ä½•æ„ä¹‰
```python
def covariance_geometry():
    """ç†è§£åæ–¹å·®çŸ©é˜µç‰¹å¾å€¼çš„å‡ ä½•æ„ä¹‰"""
    
    # ç”Ÿæˆç›¸å…³æ•°æ®
    np.random.seed(42)
    
    # ä¸¤ä¸ªå˜é‡ï¼Œæœ‰ç›¸å…³æ€§
    n_samples = 1000
    data = np.random.multivariate_normal([0, 0], [[2, 1.5], [1.5, 3]], n_samples)
    
    # è®¡ç®—åæ–¹å·®çŸ©é˜µ
    cov_matrix = np.cov(data.T)
    
    print("æ•°æ®çš„åæ–¹å·®åˆ†æ")
    print(f"åæ–¹å·®çŸ©é˜µ:\n{cov_matrix}")
    
    # ç‰¹å¾å€¼åˆ†è§£
    eigenvalues, eigenvectors = np.linalg.eig(cov_matrix)
    
    # æ’åº
    idx = np.argsort(eigenvalues)[::-1]
    eigenvalues = eigenvalues[idx]
    eigenvectors = eigenvectors[:, idx]
    
    print(f"\nç‰¹å¾å€¼: {eigenvalues}")
    print(f"ç‰¹å¾å‘é‡:\n{eigenvectors}")
    
    # æ•°æ®åœ¨ä¸»æˆåˆ†æ–¹å‘ä¸Šçš„æ–¹å·®
    print(f"\nä¸»æˆåˆ†æ–¹å‘çš„æ–¹å·®:")
    for i, (Î», v) in enumerate(zip(eigenvalues, eigenvectors.T)):
        print(f"PC{i+1}: æ–¹å·® = {Î»:.3f}, æ ‡å‡†å·® = {np.sqrt(Î»):.3f}")
        print(f"      æ–¹å‘ = {v}")
    
    # æŠ•å½±åˆ°ä¸»æˆåˆ†
    projected_data = data @ eigenvectors
    
    # éªŒè¯æŠ•å½±åçš„æ–¹å·®
    projected_var = np.var(projected_data, axis=0)
    print(f"\næŠ•å½±åçš„æ–¹å·®: {projected_var}")
    print(f"ä¸ç‰¹å¾å€¼çš„å·®å¼‚: {np.abs(projected_var - eigenvalues)}")
    
    # æ•°æ®çš„æ€»æ–¹å·®å’Œç‰¹å¾å€¼çš„å…³ç³»
    total_variance_data = np.trace(cov_matrix)
    total_variance_eigenvalues = np.sum(eigenvalues)
    
    print(f"\næ€»æ–¹å·® (trace): {total_variance_data:.3f}")
    print(f"ç‰¹å¾å€¼ä¹‹å’Œ: {total_variance_eigenvalues:.3f}")
    print(f"ç›¸ç­‰æ€§éªŒè¯: {np.allclose(total_variance_data, total_variance_eigenvalues)}")

covariance_geometry()
```

---

## ğŸ¯ å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1ï¼šå›¾åƒå‹ç¼©ä¸­çš„ç‰¹å¾å€¼åº”ç”¨
```python
def image_compression_svd_preview():
    """é¢„è§ˆSVDåœ¨å›¾åƒå‹ç¼©ä¸­çš„åº”ç”¨ï¼ˆåŸºäºç‰¹å¾å€¼ç†è§£ï¼‰"""
    
    # åˆ›å»ºä¸€ä¸ªç®€å•çš„"å›¾åƒ"ï¼ˆçŸ©é˜µï¼‰
    np.random.seed(42)
    image = np.random.randn(8, 8)
    
    # ä½¿SVDæ›´æœ‰æ„ä¹‰ï¼Œæ·»åŠ ä¸€äº›ç»“æ„
    image[:, :4] += 2  # å·¦åŠéƒ¨åˆ†æ›´äº®
    image[4:, :] -= 1  # ä¸‹åŠéƒ¨åˆ†æ›´æš—
    
    print("ç®€åŒ–çš„å›¾åƒå‹ç¼©ç¤ºä¾‹")
    print(f"åŸå§‹å›¾åƒ (8x8):\n{image}")
    
    # å¯¹äºå®å¯¹ç§°çŸ©é˜µï¼Œå¯ä»¥ç”¨ç‰¹å¾å€¼åˆ†è§£
    # è¿™é‡Œæˆ‘ä»¬æ„é€  A^T A æ¥ç¡®ä¿å¯¹ç§°æ­£å®š
    AtA = image.T @ image
    
    print(f"\nA^T A çŸ©é˜µ:\n{AtA}")
    
    # ç‰¹å¾å€¼åˆ†è§£
    eigenvalues, eigenvectors = np.linalg.eig(AtA)
    
    # æ’åº
    idx = np.argsort(eigenvalues)[::-1]
    eigenvalues = eigenvalues[idx]
    eigenvectors = eigenvectors[:, idx]
    
    print(f"\nç‰¹å¾å€¼ (ä»å¤§åˆ°å°): {eigenvalues}")
    
    # è®¡ç®—èƒ½é‡å æ¯”
    energy_ratio = eigenvalues / eigenvalues.sum()
    cumulative_energy = np.cumsum(energy_ratio)
    
    print(f"\nèƒ½é‡å æ¯”:")
    for i, (ratio, cum) in enumerate(zip(energy_ratio, cumulative_energy)):
        print(f"Î»{i+1}: {ratio:.2%}, ç´¯ç§¯: {cum:.2%}")
    
    # é€‰æ‹©ä¿ç•™å‰kä¸ªç‰¹å¾å€¼
    k_values = [2, 4, 6]
    
    for k in k_values:
        # é‡æ„çŸ©é˜µï¼ˆç®€åŒ–ç‰ˆï¼‰
        # å®é™…SVDä¼šæ›´å¤æ‚ï¼Œè¿™é‡Œåªæ˜¯æ¼”ç¤ºç‰¹å¾å€¼çš„ä½œç”¨
        selected_eigenvalues = eigenvalues[:k]
        selected_eigenvectors = eigenvectors[:, :k]
        
        # è¿™æ˜¯ç®€åŒ–çš„é‡æ„ï¼ŒçœŸå®SVDéœ€è¦å·¦å³å¥‡å¼‚å‘é‡
        reconstructed = selected_eigenvectors @ np.diag(selected_eigenvalues) @ selected_eigenvectors.T
        
        compression_ratio = k / len(eigenvalues)
        energy_preserved = cumulative_energy[k-1]
        
        print(f"\nä¿ç•™å‰ {k} ä¸ªç‰¹å¾å€¼:")
        print(f"å‹ç¼©æ¯”: {compression_ratio:.2%}")
        print(f"ä¿ç•™èƒ½é‡: {energy_preserved:.2%}")

image_compression_svd_preview()
```

### æ¡ˆä¾‹2ï¼šæŒ¯åŠ¨æ¨¡æ€åˆ†æ
```python
def vibration_modal_analysis():
    """ç»“æ„æŒ¯åŠ¨çš„æ¨¡æ€åˆ†æï¼ˆç®€åŒ–ç‰ˆï¼‰"""
    
    # ç®€åŒ–çš„æŒ¯åŠ¨ç³»ç»Ÿï¼š3è‡ªç”±åº¦ç³»ç»Ÿ
    # è´¨é‡çŸ©é˜µï¼ˆå‡è®¾å•ä½è´¨é‡ï¼‰
    M = np.eye(3)
    
    # åˆšåº¦çŸ©é˜µï¼ˆå¼¹ç°§è¿æ¥ï¼‰
    K = np.array([[2, -1, 0],
                  [-1, 2, -1],
                  [0, -1, 1]])
    
    print("æŒ¯åŠ¨ç³»ç»Ÿæ¨¡æ€åˆ†æ")
    print(f"è´¨é‡çŸ©é˜µM:\n{M}")
    print(f"åˆšåº¦çŸ©é˜µK:\n{K}")
    
    # å¹¿ä¹‰ç‰¹å¾å€¼é—®é¢˜ï¼šKÏ† = Ï‰Â²MÏ†
    # å…¶ä¸­Ï‰æ˜¯å›ºæœ‰é¢‘ç‡ï¼ŒÏ†æ˜¯æ¨¡æ€å‘é‡
    from scipy.linalg import eig
    eigenvalues, eigenvectors = eig(K, M)
    
    # ç‰¹å¾å€¼æ˜¯Ï‰Â²ï¼Œæ‰€ä»¥é¢‘ç‡æ˜¯âˆšç‰¹å¾å€¼
    frequencies = np.sqrt(eigenvalues.real)
    
    # æ’åº
    idx = np.argsort(frequencies)
    frequencies = frequencies[idx]
    mode_shapes = eigenvectors[:, idx]
    
    print(f"\nå›ºæœ‰é¢‘ç‡:")
    for i, freq in enumerate(frequencies):
        print(f"æ¨¡æ€ {i+1}: Ï‰{i+1} = {freq:.3f} rad/s")
    
    print(f"\næ¨¡æ€æŒ¯å‹:")
    for i in range(len(frequencies)):
        print(f"æ¨¡æ€ {i+1}: {mode_shapes[:, i]}")
    
    # æ¨¡æ€çš„ç‰©ç†æ„ä¹‰
    print(f"\næ¨¡æ€åˆ†æ:")
    for i in range(len(frequencies)):
        shape = mode_shapes[:, i]
        print(f"\næ¨¡æ€ {i+1} (é¢‘ç‡ {frequencies[i]:.3f}):")
        
        # åˆ†ææŒ¯å‹ç‰¹å¾
        if np.all(shape > 0) or np.all(shape < 0):
            print("  - åŒç›¸æŒ¯åŠ¨ï¼ˆåˆšä½“æ¨¡æ€æˆ–åŸºç¡€æ¨¡æ€ï¼‰")
        else:
            sign_changes = np.sum(np.diff(np.sign(shape)) != 0)
            print(f"  - æœ‰ {sign_changes} ä¸ªèŠ‚ç‚¹çš„æŒ¯åŠ¨æ¨¡æ€")
        
        # æ ‡å‡†åŒ–æ¨¡æ€å‘é‡
        normalized_shape = shape / np.linalg.norm(shape)
        print(f"  - æ ‡å‡†åŒ–æŒ¯å‹: {normalized_shape}")

vibration_modal_analysis()
```

---

## ğŸ“š æ€»ç»“ä¸å»ºè®®

### ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡çš„é‡è¦æ€§
1. **æ•°æ®é™ç»´**ï¼šPCAçš„ç†è®ºåŸºç¡€
2. **ç³»ç»Ÿåˆ†æ**ï¼šç¨³å®šæ€§å’ŒåŠ¨æ€ç‰¹æ€§
3. **å›¾åƒå¤„ç†**ï¼šSVDå’Œå‹ç¼©ç®—æ³•
4. **æœºå™¨å­¦ä¹ **ï¼šè°±èšç±»ã€æ ¸æ–¹æ³•ç­‰

### æ ¸å¿ƒç†è§£è¦ç‚¹
1. **å‡ ä½•ç›´è§‰**ï¼šä¸å˜æ–¹å‘å’Œç¼©æ”¾å€æ•°
2. **ç‰©ç†æ„ä¹‰**ï¼šå›ºæœ‰æ¨¡æ€å’Œé¢‘ç‡
3. **æ•°å€¼è®¡ç®—**ï¼šç®—æ³•ç¨³å®šæ€§å’Œç²¾åº¦
4. **åº”ç”¨åœºæ™¯**ï¼šè¯†åˆ«ä¸»è¦æˆåˆ†å’Œæ¨¡å¼

### å­¦ä¹ å»ºè®®
1. **å¯è§†åŒ–ç»ƒä¹ **ï¼š2Dæƒ…å†µä¸‹ç”»å›¾ç†è§£
2. **æ‰‹å·¥è®¡ç®—**ï¼šå°çŸ©é˜µçš„ç‰¹å¾å€¼æ±‚è§£
3. **åº”ç”¨å¯¼å‘**ï¼šç»“åˆPCAã€SVDç­‰åº”ç”¨
4. **æ•°å€¼å®éªŒ**ï¼šæµ‹è¯•ä¸åŒç±»å‹çŸ©é˜µçš„æ€§è´¨

### å¸¸è§è¯¯åŒº
1. **æ··æ·†æ¦‚å¿µ**ï¼šç‰¹å¾å€¼vså¥‡å¼‚å€¼
2. **å¿½ç•¥å¤æ•°**ï¼šéå¯¹ç§°çŸ©é˜µçš„å¤ç‰¹å¾å€¼
3. **æ•°å€¼é—®é¢˜**ï¼šç—…æ€çŸ©é˜µçš„ç‰¹å¾å€¼è®¡ç®—
4. **å‡ ä½•ç†è§£**ï¼šç¼ºä¹ç›´è§‰çš„å‡ ä½•è§£é‡Š

### ä¸‹ä¸€æ­¥å­¦ä¹ 
- å¥‡å¼‚å€¼åˆ†è§£(SVD)
- ä¸»æˆåˆ†åˆ†æ(PCA)è¯¦è§£
- è°±èšç±»ç®—æ³•
- çŸ©é˜µå‡½æ•°å’ŒçŸ©é˜µæŒ‡æ•°

---

**ğŸ” è®°ä½ï¼šç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡æ˜¯çŸ©é˜µçš„"æŒ‡çº¹"ï¼Œå®ƒä»¬æ­ç¤ºäº†æ•°æ®å’Œå˜æ¢çš„æœ¬è´¨ç‰¹å¾ï¼** 